# Go Kiro 服务：请求载荷大小检查机制

## 问题背景

当客户端发送过大的对话历史（如长时间的 Cline/Claude Code 会话），Kiro API 会返回如下错误：

```json
{"message": "Input is too long.", "reason": "CONTENT_LENGTH_EXCEEDS_THRESHOLD"}
```

**修改前的行为**：

1. Go 服务没有任何预检机制，直接将请求转发给 Kiro API
2. Kiro 返回 400 错误后，Go 服务将其视为"该账号可能不支持此模型"，标记账号不健康并重试下一个账号
3. 由于请求体对所有账号都是一样的，每个账号都会收到同样的错误
4. 最终耗尽所有重试次数（默认 3 次），浪费网络往返和账号资源

**修改前的另一个问题**：

`max_tokens` 上限验证为 200,000，但 Claude 4.5 实际最大输出为 64,000 tokens。允许客户端设置过高的 `max_tokens` 会导致 Kiro 端拒绝请求。

## 修复方案：两层检查 + 413 状态码

### 整体架构

```
客户端请求
    │
    ▼
┌─────────────────────────┐
│  validateRequest()      │  ← 修复 max_tokens 上限：200000 → 64000
│  (基本字段校验)          │
└─────────────┬───────────┘
              │
              ▼
┌─────────────────────────┐
│  Layer 1: Token 估算    │  ← 估算输入 token 数 > 200K 则拒绝 (413)
│  (发请求前，ServeHTTP)   │
└─────────────┬───────────┘
              │
              ▼
┌─────────────────────────┐
│  BuildRequestBody()     │  ← 构建 Kiro 格式请求体
└─────────────┬───────────┘
              │
              ▼
┌─────────────────────────┐
│  Layer 2: Body 大小检查  │  ← 序列化 JSON > 32MB 则拒绝 (413)
│  (转换后，重试循环内)     │
└─────────────┬───────────┘
              │
              ▼
┌─────────────────────────┐
│  发送到 Kiro API        │
│  如果仍然收到            │
│  CONTENT_LENGTH_EXCEEDS  │  ← 返回 413，不重试
│  _THRESHOLD              │
└─────────────────────────┘
```

### Layer 1：Token 估算检查

**位置**：`internal/handler/messages.go:126` — `ServeHTTP()` 中，`validateRequest` 之后

**逻辑**：

```go
estimatedInput := claude.EstimateInputTokens(&req)
if estimatedInput > claude.ContextWindowTokens {  // 200,000
    → 413 + 错误信息
}
```

直接与上下文窗口 200K 比较，不扣减 `max_tokens`。因为实际使用中很少有输出真正达到 `max_tokens`，过于严格的检查会误拦正常请求。

**Token 估算策略**（`internal/claude/usage.go:96`）：

采用保守估算（宁多不少），不同内容类型的计算方式：

| 内容类型 | 估算公式 | 说明 |
|---------|---------|------|
| 文本 | `len(text) / 3` | 3 字符/token，比实际偏高以确保安全 |
| 图片 | 固定 2,500 tokens | 不管 base64 数据多大 |
| 文档 | `base64_len * 0.25` | 最少 100 tokens |
| tool_use | `name + input / 3` | 按文本计算 |
| tool_result | 递归计算嵌套内容 | 可包含文本、图片等 |
| 每条消息 | +4 tokens 开销 | role 标记等 |
| 每个 tool 定义 | +20 tokens 开销 | JSON 结构开销 |
| thinking | +50 tokens | 思考模式开销 |

### Layer 2：请求体大小检查

**位置**：`internal/handler/messages.go:283`（streaming）和 `:723`（non-streaming）— 重试循环内，`BuildRequestBody` 之后

**逻辑**：

```go
if h.maxKiroBodySize > 0 && len(reqBody) > h.maxKiroBodySize {
    → 413 + 错误信息，直接 return（不继续重试）
}
```

检查转换为 Kiro 格式后的实际 JSON 字节数。这层作为兜底，可以捕获 Layer 1 漏过的情况（如 CJK 文本的 token 估算偏低）。

**默认值**：32 MB（`internal/claude/limits.go`），与 Claude API 限制一致。

**配置方式**：通过环境变量 `GO_KIRO_MAX_REQUEST_BODY` 覆盖（单位：字节），设为 0 则禁用此检查。

### Kiro 上游错误处理

如果 Layer 1 和 Layer 2 都没拦住，Kiro API 返回了 `CONTENT_LENGTH_EXCEEDS_THRESHOLD` 或 `Input is too long`，Go 服务现在返回 **413** 并立即终止，不再重试其他账号。

修改前返回 503（暗示"服务过载，请稍后重试"），语义不准确且会触发客户端重试。413 明确表示"请求体太大"，客户端应缩减内容而非重试。

## 修改的文件

| 文件 | 变更 |
|------|------|
| `internal/claude/limits.go` | **新增** — `ContextWindowTokens=200000`, `MaxOutputTokens=64000`, `MaxKiroRequestBodyDefault=32MB` |
| `internal/claude/errors.go` | 新增 `NewRequestTooLargeError()` 返回 413 |
| `internal/config/config.go` | 新增 `MaxKiroRequestBody` 配置字段 + `GO_KIRO_MAX_REQUEST_BODY` 环境变量 |
| `internal/handler/messages.go` | Layer 1 + Layer 2 检查；`IsContextTooLong` 改返回 413；`max_tokens` 上限改为 64000 |
| `cmd/kiro-server/main.go` | 传递 `MaxKiroBodySize` 配置到 handler |
| `tests/unit/usage_test.go` | 新增 5 个测试用例 |

## 配置参考

### 环境变量

| 变量 | 默认值 | 说明 |
|------|--------|------|
| `GO_KIRO_MAX_REQUEST_BODY` | `33554432` (32MB) | Kiro 请求体最大字节数，0 为不限制 |

### 常量（`internal/claude/limits.go`）

| 常量 | 值 | 说明 |
|------|-----|------|
| `ContextWindowTokens` | 200,000 | Claude 上下文窗口大小 |
| `MaxOutputTokens` | 64,000 | Claude 4.5 最大输出 token 数 |
| `MaxKiroRequestBodyDefault` | 32 MB | 默认请求体大小上限 |

## 客户端影响

当请求被拒绝时，客户端收到标准 Claude API 格式的错误响应：

```json
{
  "type": "error",
  "error": {
    "type": "invalid_request_error",
    "message": "Estimated input ~250000 tokens exceeds context window 200000. Reduce conversation history."
  }
}
```

HTTP 状态码 413，客户端应：
- 缩减对话历史（删除早期消息）
- 使用 `/compact` 命令压缩上下文
- 开始新对话
